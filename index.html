<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤æœç¾½çƒæ’é»åŠ©æ‰‹ (V20-åŒ¯å…¥æœªåˆ°å€ç‰ˆ)</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #27ae60;
            --bg: #f4f6f7;
            --card-bg: rgba(255, 255, 255, 0.95);
            --text: #333;
            --prep-bg: #fffcf5;
            
            /* å ´åœ°é¡è‰²è¨­å®š */
            --court-empty: #2ecc71;  /* ç¶ è‰² */
            --court-busy: #34495e;   /* æ·±è—è‰² (æœ‰äºº) */
            --court-coach: #95a5a6;  /* ç°è‰² (æ•™ç·´) */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        #bgLayer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
            background-position: center; background-repeat: no-repeat; background-size: contain;
            opacity: 0.15; pointer-events: none;
        }

        h1, h2, h3, h4 { margin: 0.5em 0; }
        
        .container { max-width: 98%; width: 100%; display: flex; flex-direction: column; gap: 15px; }

        /* Controls */
        .controls {
            background: var(--card-bg); padding: 10px 20px; border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-wrap: wrap;
            gap: 10px; align-items: center; justify-content: space-between; backdrop-filter: blur(5px);
        }

        .input-group { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

        input[type="text"], input[type="number"], select {
            padding: 6px; border: 1px solid #ccc; border-radius: 5px; font-size: 15px;
        }

        button {
            padding: 6px 12px; border: none; border-radius: 5px; cursor: pointer;
            font-size: 15px; font-weight: bold; transition: opacity 0.2s;
            display: flex; align-items: center; gap: 4px; white-space: nowrap;
        }
        button:hover { opacity: 0.9; }

        .btn-add { background-color: var(--accent); color: white; }
        .btn-auto { background-color: #3498db; color: white; }
        .btn-reset { background-color: #95a5a6; color: white; }
        .btn-export { background-color: #8e44ad; color: white; }
        .btn-import { background-color: #d35400; color: white; }
        .btn-clear-all { background-color: #c0392b; color: white; }
        .btn-bg { background-color: #f1c40f; color: #333; } 
        .btn-partner { background-color: #e84393; color: white; }
        .btn-blacklist { background-color: #34495e; color: white; }
        .btn-mini { font-size: 12px; padding: 2px 6px; }
        .btn-rest { background-color: #7f8c8d; color: white; }
        .btn-active { background-color: #27ae60; color: white; }
        .btn-absent { background-color: #95a5a6; color: white; }
        .btn-arrive { background-color: #27ae60; color: white; }
        
        /* Universal Player Button */
        .btn-universal { background-color: #f39c12; color: white; }
        .btn-universal-off { background-color: #bdc3c7; color: #555; }

        /* Layout */
        .main-area { display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-start; }

        .column-box {
            background: var(--card-bg); padding: 10px; border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); max-height: 90vh;
            display: flex; flex-direction: column; backdrop-filter: blur(5px);
        }

        .scrollable-content { overflow-y: auto; flex: 1; padding-right: 2px; }

        .col-players { flex: 1; min-width: 250px; order: 1; }
        .col-courts { flex: 3; min-width: 400px; order: 2; padding: 0; display: flex; flex-direction: column; gap: 10px; }
        .col-history { flex: 1; min-width: 250px; order: 3; }

        /* Player List */
        .section-header {
            font-size: 14px; font-weight: bold; color: #666; 
            margin: 5px 0; border-bottom: 1px solid #eee; padding-bottom: 3px;
        }
        .player-list { display: flex; flex-direction: column; gap: 5px; }

        .player-card {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 8px; border-radius: 6px; background: #f8f9fa;
            border: 1px solid #eee; cursor: pointer; user-select: none; transition: transform 0.1s;
        }
        .player-card:active { transform: scale(0.98); }
        .player-card.selected { border: 2px solid var(--primary); background: #e8f4fd; }
        .player-card.resting { opacity: 0.6; background: #eee; }
        .player-card.absent { opacity: 0.6; background: #ddd; border-style: dashed; }
        .player-card.universal-player { border-left: 4px solid #f1c40f; }

        .tag {
            padding: 2px 6px; border-radius: 4px; color: white; font-size: 11px;
            font-weight: bold; margin-right: 5px; min-width: 20px; text-align: center;
            cursor: help;
        }
        .lvl-low { background-color: #27ae60; } 
        .lvl-mid { background-color: #2980b9; } 
        .lvl-high { background-color: #e74c3c; } 

        .count-badge {
            background: #34495e; color: white; border-radius: 50%; width: 20px; height: 20px;
            display: flex; align-items: center; justify-content: center; font-size: 11px; margin-right: 5px;
        }
        
        .time-badge { font-size: 10px; color: #888; margin-right: 5px; font-family: monospace; }
        .name-edit { border-bottom: 1px dashed #999; cursor: text; font-size: 14px; }

        /* Prep Area */
        .prep-controls-header { display: flex; justify-content: space-between; align-items: center; padding: 0 5px; margin-bottom: 5px;}
        .prep-container { display: flex; flex-direction: column; gap: 8px; margin-bottom: 5px; }
        .prep-row {
            background: var(--prep-bg); border: 2px dashed #f39c12; border-radius: 8px;
            padding: 5px 10px; display: flex; flex-direction: column; gap: 5px;
            transition: all 0.2s;
        }
        .prep-row.moving-mode {
            border-color: #e74c3c; background: #fff0f0; box-shadow: 0 0 10px rgba(231, 76, 60, 0.3);
        }
        .prep-header { display: flex; justify-content: space-between; align-items: center; }
        .prep-label { font-weight: bold; color: #d35400; font-size: 13px; }
        .prep-actions { display: flex; gap: 3px; }

        /* Grid */
        .courts-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 15px; }

        /* Court Styles */
        .court {
            background: var(--court-empty); /* Default Green */
            border: 4px solid white; border-radius: 4px; padding: 10px;
            display: flex; flex-direction: column; gap: 8px; position: relative;
            box-shadow: 0 3px 5px rgba(0,0,0,0.2); transition: box-shadow 0.3s;
        }
        
        /* Occupied State */
        .court.occupied {
            background: var(--court-busy); /* Deep Blue */
            border-color: #ccc;
        }

        .court.swapping { box-shadow: 0 0 15px 5px yellow; border-color: yellow; animation: pulse 1s infinite; }
        .court.target-mode { box-shadow: 0 0 15px 5px #e74c3c; border-color: #e74c3c; cursor: pointer; transform: scale(1.02); }
        .court.coaching-mode { background: var(--court-coach); border-color: #7f8c8d; }

        .coaching-overlay {
            position: absolute; top: 45px; left: 0; width: 100%; height: calc(100% - 45px);
            background: rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center;
            color: white; font-size: 24px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5; pointer-events: none;
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

        .court-header { 
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px; 
            position: relative; z-index: 10;
        }
        .court-title { color: white; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.5); font-size: 16px; margin-right: 10px;}
        .court-controls { display: flex; align-items: center; gap: 10px; width: 100%; justify-content: space-between;}
        
        .court-actions { display: flex; gap: 3px; flex-wrap: wrap; justify-content: flex-end; }

        .btn-court-action {
            border: 1px solid white; color: white; font-size: 11px; padding: 2px 6px;
            border-radius: 12px; cursor: pointer; white-space: nowrap;
        }
        .btn-clear { background: rgba(0,0,0,0.3); } .btn-clear:hover { background: #c0392b; }
        .btn-speak { background: #2980b9; } .btn-speak:hover { background: #3498db; }
        .btn-auto-court { background: #d35400; } .btn-auto-court:hover { background: #e67e22; }
        .btn-swap { background: #8e44ad; } .btn-swap:hover { background: #9b59b6; }
        .btn-move-in { background: #16a085; border:1px solid #16a085; } .btn-move-in:hover { background: #1abc9c; }
        .btn-coach { background: #2c3e50; } .btn-coach:hover { background: #34495e; }
        .btn-coach.active { background: #c0392b; border-color: #c0392b; font-weight: bold; }

        .net { height: 4px; background: white; width: 100%; margin: 4px 0; opacity: 0.8; }
        .team { display: flex; gap: 8px; justify-content: space-around; }

        .slot {
            background: rgba(255,255,255,0.9); border-radius: 6px; 
            min-height: 60px; 
            flex: 1;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; border: 2px dashed #ccc; position: relative;
        }
        .slot:hover { border-color: #666; }
        .slot-content { text-align: center; width: 100%; }
        .slot-name { 
            font-weight: bold; 
            font-size: 26px; /* 2x size */
            line-height: 1.1;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 150px; 
        }
        .slot-level { font-size: 10px; margin-top: 2px; }

        .remove-slot-btn {
            position: absolute; top: -5px; right: -5px; background: red; color: white;
            border-radius: 50%; width: 16px; height: 16px; font-size: 10px; line-height: 16px;
            text-align: center; display: none; z-index: 10;
        }
        .slot.filled:hover .remove-slot-btn { display: block; }
        .slot.filled { border: 2px solid var(--primary); border-style: solid; }

        /* History */
        .history-list { list-style: none; padding: 0; margin: 0; }
        .history-item { 
            border-bottom: 1px solid #eee; padding: 6px 4px; 
            display: flex; flex-direction: column; gap: 3px;
            font-size: 12px; color: #333; background: #fff;
        }
        .history-item:nth-child(even) { background-color: #fafafa; }
        
        .history-header { display: flex; justify-content: space-between; align-items: center; }
        .history-time { font-family: monospace; color: #666; background: #eee; padding: 1px 4px; border-radius: 3px; font-size: 11px; }
        .match-badge { background: #7f8c8d; color: white; border-radius: 3px; padding: 1px 5px; font-size: 10px; }
        
        .history-players { display: flex; flex-wrap: wrap; gap: 2px; align-items: center; line-height: 1.3; }
        .delete-hist-btn { color: #ccc; cursor: pointer; font-size: 14px; padding: 0 5px; }
        .delete-hist-btn:hover { color: red; }

        /* Tables & Modal */
        .stats-table, .partner-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px; }
        .stats-table th, .stats-table td, .partner-table th, .partner-table td { border: 1px solid #ddd; padding: 6px; text-align: center; }
        .stats-table th { background-color: #f2f2f2; }
        
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
        .modal-content { background-color: white; padding: 20px; border-radius: 10px; max-width: 800px; width: 90%; max-height: 90vh; overflow-y: auto; }
        .close-modal { float: right; font-size: 28px; font-weight: bold; cursor: pointer; }

        @media (max-width: 1024px) {
            .col-players { order: 1; flex: 100%; }
            .col-courts { order: 2; flex: 100%; }
            .col-history { order: 3; flex: 100%; }
        }
    </style>
</head>
<body>

<div id="bgLayer"></div>

<div class="container">
    <div class="controls">
        <div class="input-group">
            <h3 style="color:var(--primary); margin:0;">å¤æœæ’é»åŠ©æ‰‹</h3>
        </div>
        
        <div class="input-group">
            <input type="text" id="pName" placeholder="å§“å" style="width:100px;">
            <select id="pLevel" style="width:70px;">
                </select>
            <button class="btn-add" onclick="addPlayer()">+ åŠ äºº</button>
        </div>

        <div class="input-group">
            <label>å ´åœ°ï¼š</label>
            <input type="number" id="courtCount" value="4" min="1" max="8" style="width: 40px;" onchange="renderCourts()">
        </div>

        <div class="input-group">
            <label>ğŸ—£ï¸ èªéŸ³ï¼š</label>
            <select id="voiceSelect" onchange="saveSettings()">
                <option value="female">ğŸ‘© å¥³è² (é è¨­)</option>
                <option value="male">ğŸ‘¨ ç”·è² (å˜—è©¦)</option>
                <option value="tw">ğŸ¦œ å°èª (éœ€è£ç½®æ”¯æ´)</option>
            </select>
        </div>

        <div class="input-group">
            <button class="btn-auto" onclick="autoAssignAll()">ğŸ² å…¨å ´è£œæ»¿</button>
            <button class="btn-partner" onclick="showPartnerModal()">â¤ï¸ æ­æª”</button>
            <button class="btn-blacklist" onclick="showBlacklistModal()">ğŸš« è¿´é¿</button>
            <button class="btn-export" onclick="showStats()">ğŸ“Š çµ±è¨ˆ</button>
            
            <input type="file" id="csvInput" accept=".csv" style="display:none" onchange="handleFileUpload(event)">
            <input type="file" id="bgInput" accept="image/*" style="display:none" onchange="handleBgUpload(event)">
            
            <button class="btn-import" onclick="document.getElementById('csvInput').click()">ğŸ“‚ åŒ¯å…¥</button>
            <button class="btn-bg" onclick="document.getElementById('bgInput').click()">ğŸ–¼ï¸ èƒŒæ™¯</button>
            <button class="btn-clear-all" onclick="clearAllData()">âš ï¸ é‡ç½®</button>
        </div>
    </div>

    <div class="main-area">
        <div class="column-box col-players">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3>äººå“¡åå–® (<span id="waitCount">0</span>)</h3>
            </div>
            <div class="scrollable-content">
                <div class="section-header">å€™ä½å€ (å¯ä¸Šå ´)</div>
                <div id="playerList" class="player-list"></div>
                
                <div class="section-header" style="margin-top:20px;">ä¼‘æ¯å€ (æš«åœæ’é»)</div>
                <div id="restList" class="player-list"></div>

                <div class="section-header" style="margin-top:20px; color:#95a5a6; border-color:#ccc;">æœªåˆ°å€ (å°šæœªæŠµé”)</div>
                <div id="absentList" class="player-list"></div>
            </div>
        </div>

        <div class="col-courts">
            <div class="prep-controls-header">
                <strong>å‚™æˆ°å€</strong>
                <div style="display:flex; gap:5px;">
                    <button class="btn-mini btn-add" title="å¢åŠ å‚™æˆ°å€" onclick="addPrepRow()">+ å¢åŠ </button>
                    <button class="btn-mini btn-rest" title="æ¸›å°‘å‚™æˆ°å€" onclick="removePrepRow()">- æ¸›å°‘</button>
                </div>
            </div>
            <div class="prep-container" id="prepContainer"></div>

            <div id="courtsGrid" class="courts-grid"></div>
        </div>

        <div class="column-box col-history">
            <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #eee; padding-bottom:5px; margin-bottom:5px;">
                <h3>å°æˆ°ç´€éŒ„</h3>
                <button class="btn-mini-clear" onclick="clearHistory()">ğŸ—‘ï¸ æ¸…ç©º</button>
            </div>
            <div class="scrollable-content">
                 <ul id="historyListMain" class="history-list"></ul>
            </div>
        </div>
    </div>
</div>

<div id="statsModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeModal('statsModal')">&times;</span>
        <h2>çµ±è¨ˆè¡¨</h2>
        <button class="btn-export" onclick="exportCSV()">ä¸‹è¼‰ CSV</button>
        <table class="stats-table">
            <thead><tr><th>å§“å</th><th>ç¨‹åº¦</th><th>ç™½æ­ç‹</th><th>å ´æ¬¡</th><th>åˆ°å ´æ™‚é–“</th><th>ç›®å‰ä¼‘æ¯</th><th>ä¸‹å ´æ™‚é–“ç´€éŒ„</th></tr></thead>
            <tbody id="statsBody"></tbody>
        </table>
    </div>
</div>

<div id="partnerModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeModal('partnerModal')">&times;</span>
        <h2>å›ºå®šæ­æª”</h2>
        <div style="margin-bottom:10px; background:#f9f9f9; padding:10px;">
            <select id="partnerP1" style="width:40%"></select> + <select id="partnerP2" style="width:40%"></select>
            <button class="btn-add" onclick="addPartner()" style="margin-top:5px;">ç¶å®š</button>
        </div>
        <table class="partner-table"><tbody id="partnerListBody"></tbody></table>
    </div>
</div>

<div id="blacklistModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeModal('blacklistModal')">&times;</span>
        <h2>è¿´é¿è¨­å®š (ä¸èƒ½åŒå ´)</h2>
        <div style="margin-bottom:10px; background:#f9f9f9; padding:10px;">
            <select id="blP1" style="width:40%"></select> X <select id="blP2" style="width:40%"></select>
            <button class="btn-blacklist" onclick="addBlacklist()" style="margin-top:5px;">è¨­å®š</button>
        </div>
        <table class="partner-table"><tbody id="blacklistBody"></tbody></table>
    </div>
</div>

<script>
    // --- Data Model ---
    let players = [];
    let courts = []; 
    let prepCourts = [[null,null,null,null], [null,null,null,null]];
    let matchHistory = []; 
    let courtCoaching = []; 
    
    let selectedPlayerId = null;
    let swapSourceIndex = null; 
    let movingPrepIndex = null; 
    let availableVoices = [];

    // --- Time Helper ---
    function getCurrentTimeStr() {
        const now = new Date();
        return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
    }

    // --- Init ---
    window.onload = function() {
        initLevelSelect();
        loadData();
        if(courts.length === 0) renderCourts();
        if(!prepCourts || prepCourts.length === 0) prepCourts = [[null,null,null,null], [null,null,null,null]];
        
        renderAll();
        loadBgImage();
        initVoices();
    };

    function initLevelSelect() {
        const s = document.getElementById('pLevel'); s.innerHTML = '';
        for(let i=3; i<=15; i++) {
            const opt = document.createElement('option');
            opt.value = i; opt.innerText = i+"ç´š";
            if(i===6) opt.selected = true;
            s.appendChild(opt);
        }
    }

    // --- Voice Logic ---
    function initVoices() {
        window.speechSynthesis.onvoiceschanged = () => {
            availableVoices = window.speechSynthesis.getVoices().filter(v => v.lang.includes('zh') || v.lang.includes('nan') || v.lang.includes('min'));
        };
        availableVoices = window.speechSynthesis.getVoices().filter(v => v.lang.includes('zh') || v.lang.includes('nan') || v.lang.includes('min'));
    }

    function speakCourt(i) {
        if (courtCoaching[i]) return;
        const names = courts[i].filter(x=>x).map(x=>x.name);
        if(names.length === 0) return alert("ç„¡äºº");

        const text = `ç¬¬${i+1}å ´åœ°ï¼Œè«‹${names.join('ã€')}ä¸Šå ´`;
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'zh-TW';
        utterance.rate = 1;

        const genderPref = document.getElementById('voiceSelect').value;
        let selectedVoice = null;

        if (availableVoices.length > 0) {
            if (genderPref === 'male') {
                selectedVoice = availableVoices.find(v => v.name.includes('Male') || v.name.includes('Man') || v.name.includes('Danny') || v.name.includes('Zhanyuan') || v.name.includes('Kangkang'));
            } else if (genderPref === 'tw') {
                selectedVoice = availableVoices.find(v => v.lang.includes('nan') || v.name.includes('Min') || v.name.includes('Hokkien') || v.name.includes('Taiwanese'));
                if (!selectedVoice) selectedVoice = availableVoices.find(v => v.lang === 'zh-TW');
            } else {
                selectedVoice = availableVoices.find(v => v.name.includes('Female') || v.name.includes('Woman') || v.name.includes('Huihui') || v.name.includes('Yaoyao') || v.name.includes('Hanhan') || v.name.includes('Ting-Ting'));
            }
            if (!selectedVoice) selectedVoice = availableVoices[0];
            utterance.voice = selectedVoice;
        }

        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utterance);
    }

    // --- CSV Import ---
    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            let content = e.target.result;
            if(isContentValid(content)) { processCSVContent(content); }
            else {
                const reader2 = new FileReader();
                reader2.onload = (e2) => processCSVContent(e2.target.result);
                reader2.readAsText(file, 'Big5');
            }
            event.target.value = '';
        };
        reader.readAsText(file);
    }
    function isContentValid(c) { return c.includes(',') || c.includes('å§“å') || c.includes('Name'); }
    
    function processCSVContent(content) {
        if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
        const lines = content.split(/\r\n|\n|\r/);
        let added = 0;
        const batchTime = getCurrentTimeStr();

        lines.forEach(line => {
            const parts = line.split(',');
            if (parts.length >= 2) {
                const name = parts[0].trim().replace(/^"|"$/g, '');
                const level = parseInt(parts[1].replace(/[^0-9]/g, ''));
                if (!name.includes("å§“å") && !isNaN(level)) {
                    if (!players.some(p => p.name === name)) {
                        createPlayer(name, level, batchTime);
                        // V20 ä¿®æ”¹ï¼šåŒ¯å…¥åå–®é è¨­ç‚ºæœªåˆ°å€ (isAbsent = true)
                        players[players.length - 1].isAbsent = true;
                        added++;
                    }
                }
            }
        });
        saveData(); renderPlayerList();
        if(added>0) alert(`å·²åŒ¯å…¥ ${added} äºº (å…¨éƒ¨é è¨­è‡³æœªåˆ°å€)`); else alert("åŒ¯å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ ¼å¼");
    }

    function createPlayer(name, level, timeStr) {
        players.push({
            id: Date.now() + Math.random().toString(),
            name, level, count: 0, lastPlayedTime: 0,
            onCourt: false, isResting: false,
            isAbsent: false, 
            isUniversal: false, 
            partnerId: null, blacklist: [],
            arrivalTime: timeStr || getCurrentTimeStr(),
            currentStartTime: null,
            matchEndTimes: []
        });
    }

    // --- Play Logic ---
    function startPlay(p) {
        p.onCourt = true;
        p.currentStartTime = Date.now();
    }

    function resetPlayerState(p) {
        p.onCourt = false;
        p.currentStartTime = null;
    }

    function recordGameStats(p) {
        p.count++;
        p.lastPlayedTime = Date.now();
        if (!p.matchEndTimes) p.matchEndTimes = [];
        p.matchEndTimes.push(getCurrentTimeStr());
    }

    // --- Core Player Mgmt ---
    function addPlayer() {
        const n = document.getElementById('pName').value.trim();
        const l = parseInt(document.getElementById('pLevel').value);
        if(!n) return alert("è«‹è¼¸å…¥å§“å");
        if(players.some(p=>p.name===n)) return alert("å§“åé‡è¤‡");
        createPlayer(n, l, getCurrentTimeStr());
        saveData(); renderPlayerList(); document.getElementById('pName').value='';
    }

    function removePlayer(id, evt) {
        evt.stopPropagation();
        if(!confirm("åˆªé™¤æ­¤äºº?")) return;
        players = players.filter(p=>p.id!==id);
        courts = courts.map(c => c.map(p => (p && p.id===id)?null:p));
        prepCourts = prepCourts.map(row => row.map(p => (p && p.id===id)?null:p));
        saveData(); renderAll();
    }

    function toggleRest(id, evt) {
        evt.stopPropagation();
        const p = players.find(x=>x.id===id);
        if(p) { 
            const wasResting = p.isResting;
            p.isResting = !p.isResting; 
            // å¦‚æœå¾ä¼‘æ¯å€ç§»å›å€™ä½å€ (ä¸Šå ´)ï¼Œæ›´æ–°åˆ°å ´æ™‚é–“ä»¥é‡æ–°æ’éšŠ
            if (wasResting && !p.isResting) {
                p.arrivalTime = getCurrentTimeStr();
            }
        }
        saveData(); renderPlayerList();
    }

    function toggleAbsent(id, evt) {
        evt.stopPropagation();
        const p = players.find(x=>x.id===id);
        if(!p) return;

        if (p.isAbsent) {
            // Check In (å ±åˆ°)ï¼šå¾æœªåˆ° -> å€™ä½
            p.isAbsent = false;
            p.isResting = false;
            p.arrivalTime = getCurrentTimeStr(); // æ›´æ–°ç‚ºç•¶ä¸‹æ™‚é–“
        } else {
            // Mark Absent (è¨­ç‚ºæœªåˆ°)
            if(p.onCourt) return alert("å ´ä¸Šçƒå“¡ä¸èƒ½è¨­ç‚ºæœªåˆ°");
            p.isAbsent = true;
            p.isResting = false;
            prepCourts = prepCourts.map(r => r.map(x => (x && x.id===id)? null : x));
        }
        saveData(); renderAll();
    }

    function toggleUniversal(id, evt) {
        evt.stopPropagation();
        const p = players.find(x=>x.id===id);
        if(p) { p.isUniversal = !p.isUniversal; }
        saveData(); renderPlayerList();
    }

    function renamePlayer(id) {
        const p = players.find(x=>x.id===id);
        if(!p) return;
        const newName = prompt("ä¿®æ”¹åå­—:", p.name);
        if(newName && newName.trim() !== "") {
            p.name = newName.trim();
            saveData(); renderAll();
        }
    }

    function editLevel(id) {
        const p = players.find(x=>x.id===id);
        if(!p) return;
        const val = prompt(`ä¿®æ”¹ ${p.name} çš„ç¨‹åº¦ (3-15):`, p.level);
        if(val) {
            const n = parseInt(val);
            if(!isNaN(n) && n>=3 && n<=15) {
                p.level = n;
                saveData(); renderAll();
            } else {
                alert("è«‹è¼¸å…¥æœ‰æ•ˆæ•¸å­— 3-15");
            }
        }
    }

    // --- Court Swap ---
    function initiateSwap(idx) {
        if (courtCoaching[idx]) return alert("æ•™ç·´èª²å ´åœ°ç„¡æ³•äº¤æ›");
        if (swapSourceIndex === null) {
            swapSourceIndex = idx;
            renderCourts();
        } else {
            if (swapSourceIndex !== idx) {
                if (courtCoaching[swapSourceIndex]) return alert("æ•™ç·´èª²å ´åœ°ç„¡æ³•äº¤æ›");
                const temp = [...courts[swapSourceIndex]];
                courts[swapSourceIndex] = [...courts[idx]];
                courts[idx] = temp;
                saveData();
            }
            swapSourceIndex = null;
            renderCourts();
        }
    }

    // --- Prep Area Logic ---
    function addPrepRow() {
        prepCourts.push([null,null,null,null]);
        saveData(); renderPrep(); renderPlayerList();
    }

    function removePrepRow() {
        if(prepCourts.length === 0) return;
        const lastRow = prepCourts[prepCourts.length-1];
        if(lastRow.some(p=>p!==null)) {
            if(!confirm("æœ€å¾Œä¸€æ’å‚™æˆ°å€é‚„æœ‰äººï¼Œç¢ºå®šç§»é™¤ä¸¦é€€å›å€™ä½å€ï¼Ÿ")) return;
        }
        prepCourts.pop();
        saveData(); renderPrep(); renderPlayerList();
    }

    function clickPrepSlot(rowIdx, slotIdx) {
        if (selectedPlayerId) {
            const p = players.find(x=>x.id===selectedPlayerId);
            if(!p) return;
            if(p.onCourt) return alert("è©²çƒå“¡å·²åœ¨å ´ä¸Š");
            if(p.isAbsent) return alert("æœªåˆ°çƒå“¡ä¸èƒ½æ’é»");
            if(prepCourts.some(row => row.some(x => x && x.id === p.id))) return alert("å·²åœ¨å‚™æˆ°å€");
            
            let current = prepCourts[rowIdx].filter(x=>x);
            let val = checkGroupValidityWithReason([...current, p]); 
            if(!val.valid && !confirm(`è¦å‰‡è­¦å‘Š: ${val.reason}ï¼Œè¦æ’å…¥å—?`)) return;

            prepCourts[rowIdx][slotIdx] = p;
            selectedPlayerId = null;
            saveData(); renderAll();
        }
    }
    
    function removePrepSlot(rowIdx, slotIdx, evt) {
        evt.stopPropagation();
        prepCourts[rowIdx][slotIdx] = null;
        saveData(); renderAll();
    }

    function autoFillPrep(rowIdx) {
        const emptyIndices = prepCourts[rowIdx].map((p,i)=>p===null?i:-1).filter(i=>i!==-1);
        if(emptyIndices.length === 0) return alert("æ­¤å‚™æˆ°åˆ—å·²æ»¿");
        
        let current = prepCourts[rowIdx].filter(x=>x);
        let pool = getSortedWaitingList();
        pool = pool.filter(p => !prepCourts.some(r => r.includes(p)));

        if(current.length > 0) pool = pool.filter(p => isGroupValid([...current, p]));

        const match = findBestGroupWithScore(pool, emptyIndices.length, current);
        if(match.length === emptyIndices.length) {
            match.forEach((p, i) => prepCourts[rowIdx][emptyIndices[i]] = p);
            saveData(); renderAll();
        } else {
            alert("æ‰¾ä¸åˆ°é©åˆçš„äººé¸");
        }
    }

    function clearPrep(rowIdx) { prepCourts[rowIdx] = [null,null,null,null]; saveData(); renderAll(); }

    function movePrepToCourtStart(rowIdx) {
        if(prepCourts[rowIdx].every(p=>p===null)) return alert("æ­¤å‚™æˆ°åˆ—æ˜¯ç©ºçš„");
        movingPrepIndex = rowIdx;
        renderPrep(); renderCourts();
    }

    function movePrepToCourtEnd(courtIdx) {
        if(movingPrepIndex === null) return;
        if(courtCoaching[courtIdx]) return alert("æ­¤ç‚ºæ•™ç·´å ´åœ°ï¼Œç„¡æ³•ç§»å…¥");

        if(courts[courtIdx].some(p=>p!==null)) {
            if(!confirm("è©²å ´åœ°å·²æœ‰çƒå“¡ï¼Œç¢ºå®šè¦è¦†è“‹å—ï¼Ÿ")) {
                movingPrepIndex = null; renderAll(); return;
            }
            courts[courtIdx].forEach(p => { if(p) { resetPlayerState(p); } });
        }

        const newPlayers = [...prepCourts[movingPrepIndex]];
        courts[courtIdx] = newPlayers;
        newPlayers.forEach(p => { if(p) startPlay(p); });
        
        prepCourts[movingPrepIndex] = [null,null,null,null];
        movingPrepIndex = null;
        saveData(); renderAll();
    }

    // --- Main Court Interaction ---
    function toggleCoaching(courtIdx) {
        if (!courtCoaching[courtIdx]) { // Turning ON
            if(courts[courtIdx].some(p=>p!==null)) {
                if(!confirm("åˆ‡æ›ç‚ºæ•™ç·´èª²å°‡æ¸…ç©ºç›®å‰å ´ä¸Šäººå“¡ä¸¦é€€å›å€™ä½å€ï¼Œç¢ºå®šå—ï¼Ÿ")) return;
                courts[courtIdx].forEach(p => { if(p) resetPlayerState(p); });
                courts[courtIdx] = [null,null,null,null];
            }
        }
        courtCoaching[courtIdx] = !courtCoaching[courtIdx];
        saveData();
        renderAll();
    }

    function clickSlot(courtIdx, slotIdx) {
        if(courtCoaching[courtIdx]) return;
        if (movingPrepIndex !== null) { movePrepToCourtEnd(courtIdx); return; }
        if (swapSourceIndex !== null) { initiateSwap(courtIdx); return; }

        if (selectedPlayerId) {
            const p = players.find(x=>x.id===selectedPlayerId);
            if(!p) return;
            if(p.onCourt) return alert("å·²åœ¨å ´ä¸Š");
            if(p.isAbsent) return alert("æœªåˆ°çƒå“¡ä¸èƒ½æ’é»");
            if(prepCourts.some(r => r.some(x => x && x.id === p.id))) return alert("å·²åœ¨å‚™æˆ°å€");

            const court = courts[courtIdx];
            const current = court.filter(x=>x);
            const val = checkGroupValidityWithReason([...current, p]);
            
            if(!val.valid && !confirm(`è¦å‰‡è­¦å‘Š: ${val.reason}ï¼Œè¦æ’å…¥å—?`)) return;

            court[slotIdx] = p;
            startPlay(p);

            if(p.partnerId) {
                const partner = players.find(x=>x.id===p.partnerId);
                if(partner && !partner.onCourt && !partner.isAbsent) {
                    const pIdx = (slotIdx%2===0)?slotIdx+1:slotIdx-1;
                    if(court[pIdx]===null) {
                        const current2 = court.filter(x=>x); 
                        if(checkGroupValidityWithReason([...current2, partner]).valid || confirm(`æ­æª” ${partner.name} æœ‰è¡çªï¼Œè¦å¼·åˆ¶åŠ å…¥å—?`)) {
                            court[pIdx] = partner;
                            startPlay(partner);
                        }
                    }
                }
            }
            selectedPlayerId = null; saveData(); renderAll();
        }
    }

    function removeSlot(courtIdx, slotIdx, evt) {
        evt.stopPropagation();
        const p = courts[courtIdx][slotIdx];
        if(p) {
            resetPlayerState(p); 
            courts[courtIdx][slotIdx] = null;
            saveData(); renderAll();
        }
    }

    // --- Logic ---
    function checkGroupValidityWithReason(group) {
        for(let i=0; i<group.length; i++) {
            for(let j=i+1; j<group.length; j++) {
                if(group[i].blacklist && group[i].blacklist.includes(group[j].id))
                    return {valid:false, reason:`è¿´é¿è¨­å®š (${group[i].name} X ${group[j].name})`};
            }
        }

        const hasUniversal = group.some(p => p.isUniversal);
        if (hasUniversal) return {valid:true};

        if(group.length > 1) {
            const levels = group.map(p=>p.level);
            const max = Math.max(...levels);
            const min = Math.min(...levels);
            
            if(max - min > 4) {
                const hasPartners = group.some(p => p.partnerId && group.some(g => g.id === p.partnerId));
                if (!hasPartners) {
                    return {valid:false, reason:`ç­‰ç´šå·®è·éå¤§ (${max}-${min} > 4)`};
                }
            }
        }
        return {valid:true};
    }

    function isGroupValid(group) { return checkGroupValidityWithReason(group).valid; }
    
    function autoAssignAll() {
        const n = parseInt(document.getElementById('courtCount').value);
        for(let i=0; i<n; i++) autoAssignSingleLogic(i, false);
        saveData(); renderAll();
    }
    
    function autoAssignSingle(i) {
        if(autoAssignSingleLogic(i, true)) { saveData(); renderAll(); }
    }

    function autoAssignSingleLogic(courtIdx, alertOnFail) {
        if(courtCoaching[courtIdx]) { if(alertOnFail) alert("æ­¤ç‚ºæ•™ç·´å ´åœ°"); return false; }
        
        const court = courts[courtIdx];
        const empties = court.map((p,i)=>p===null?i:-1).filter(i=>i!==-1);
        if(empties.length===0) { if(alertOnFail) alert("å ´åœ°å·²æ»¿"); return false; }

        // --- V18 æ–°å¢ï¼šå‚™æˆ°å€å„ªå…ˆé‚è¼¯ ---
        if (empties.length === 4) {
            // Find full prep row
            const fullPrepIndex = prepCourts.findIndex(row => row.every(p => p !== null));
            if (fullPrepIndex !== -1) {
                const prepRow = prepCourts[fullPrepIndex];
                prepRow.forEach((p, i) => {
                    court[i] = p;
                    startPlay(p);
                });
                prepCourts[fullPrepIndex] = [null, null, null, null];
                return true; 
            }
        }
        // -----------------------------

        const current = court.filter(x=>x);
        let pool = getSortedWaitingList(); 

        if (current.length > 0) pool = pool.filter(p => isGroupValid([...current, p]));

        const match = findBestGroupWithScore(pool, empties.length, current);
        if(match.length === empties.length) {
            match.forEach((p, i) => {
                court[empties[i]] = p;
                startPlay(p);
            });
            return true;
        } else {
            if(alertOnFail) alert("ç„¡é©åˆäººé¸");
            return false;
        }
    }

    function findBestGroupWithScore(fullPool, needed, existing) {
        if (fullPool.length < needed) return [];

        const seedLimit = Math.min(fullPool.length, 12); 

        let bestGroup = [];
        let lowestScore = Infinity;

        for (let i = 0; i < seedLimit; i++) {
            let p1 = fullPool[i];
            let potentialGroup = [p1];
            let usedIds = new Set([p1.id]);
            
            if (p1.partnerId) {
                let partner = fullPool.find(x => x.id === p1.partnerId);
                if (partner && !usedIds.has(partner.id)) {
                    let testGroup = [...existing, p1, partner];
                    if (isGroupValid(testGroup)) {
                        if(needed >= 2) {
                            potentialGroup.push(partner);
                            usedIds.add(partner.id);
                        } else {
                            continue;
                        }
                    } else {
                        continue; 
                    }
                } else if (!partner && players.find(x => x.id === p1.partnerId && (x.onCourt || x.isAbsent))) {
                     continue; 
                }
            } else {
                if (!isGroupValid([...existing, p1])) continue;
            }

            if (potentialGroup.length < needed) {
                for (let k = 0; k < fullPool.length; k++) {
                    if (potentialGroup.length === needed) break;
                    let cand = fullPool[k];
                    if (usedIds.has(cand.id)) continue;

                    if (cand.partnerId) {
                        if (needed - potentialGroup.length < 2) continue;
                        let cPartner = fullPool.find(x => x.id === cand.partnerId);
                        if (cPartner && !usedIds.has(cPartner.id)) {
                            let testG = [...existing, ...potentialGroup, cand, cPartner];
                            if (isGroupValid(testG)) {
                                potentialGroup.push(cand, cPartner);
                                usedIds.add(cand.id); usedIds.add(cPartner.id);
                            }
                        }
                    } else {
                        if (isGroupValid([...existing, ...potentialGroup, cand])) {
                            potentialGroup.push(cand);
                            usedIds.add(cand.id);
                        }
                    }
                }
            }

            if (potentialGroup.length === needed) {
                let score = calculateGroupScore([...existing, ...potentialGroup]);
                if (score < lowestScore) {
                    lowestScore = score;
                    bestGroup = potentialGroup;
                }
                if (score === 0) break;
            }
        }
        return bestGroup;
    }

    function calculateGroupScore(group) {
        let score = 0;
        for (let i = 0; i < group.length; i++) {
            for (let j = i + 1; j < group.length; j++) {
                if (hasPaired(group[i], group[j])) score += 5000;
                if (hasPlayedInSameMatch(group[i], group[j])) score += 100;
            }
        }
        const totalCounts = group.reduce((sum, p) => sum + p.count, 0);
        score += totalCounts * 10; 
        return score;
    }

    function hasPaired(p1, p2) {
        for (let m of matchHistory) {
            const ids = m.playerIds;
            if (ids.length < 4) continue;
            const p1InT1 = (ids[0]===p1.id || ids[1]===p1.id);
            const p2InT1 = (ids[0]===p2.id || ids[1]===p2.id);
            const p1InT2 = (ids[2]===p1.id || ids[3]===p1.id);
            const p2InT2 = (ids[2]===p2.id || ids[3]===p2.id);
            if ((p1InT1 && p2InT1) || (p1InT2 && p2InT2)) return true;
        }
        return false;
    }

    function hasPlayedInSameMatch(p1, p2) {
        for (let m of matchHistory) {
            if (m.playerIds.includes(p1.id) && m.playerIds.includes(p2.id)) return true;
        }
        return false;
    }

    function getSortedWaitingList() {
        return players.filter(p => !p.onCourt && !p.isResting && !p.isAbsent && !prepCourts.some(r=>r.includes(p))).sort((a,b) => {
            return (a.lastPlayedTime||0) - (b.lastPlayedTime||0);
        });
    }

    // --- UI Render ---
    function renderCourts() {
        const n = parseInt(document.getElementById('courtCount').value);
        const grid = document.getElementById('courtsGrid');
        
        while(courts.length < n) { courts.push([null,null,null,null]); courtCoaching.push(false); }
        if(courts.length > n) { courts.length = n; courtCoaching.length = n; }
        for(let k=0; k<n; k++) { if(courtCoaching[k]===undefined) courtCoaching[k]=false; }

        let html = '';
        courts.forEach((court, i) => {
            const isTarget = (movingPrepIndex !== null);
            const isSwapping = (swapSourceIndex === i);
            const isCoach = courtCoaching[i];
            const isOccupied = court.some(p => p !== null); 
            const coachBtnText = isCoach ? "âŒ è§£é™¤" : "ğŸ‘¨â€ğŸ« æ•™ç·´";
            
            const slots = court.map((p, si) => {
                if(!p) return `<div class="slot" onclick="clickSlot(${i},${si})"><span style="color:#ccc;font-size:20px;">+</span></div>`;
                const cls = (p.level<=6)?'lvl-low':(p.level>=11?'lvl-high':'lvl-mid');
                const uStar = p.isUniversal ? 'ğŸŒŸ' : '';
                return `
                <div class="slot filled" onclick="clickSlot(${i},${si})">
                    <div class="remove-slot-btn" onclick="removeSlot(${i},${si},event)">Ã—</div>
                    <div class="slot-content">
                        <div class="slot-name">
                            ${uStar}${p.name}
                            <span style="font-size:16px; color:#555; font-weight:normal;">(${p.count})</span>
                        </div>
                        <div class="slot-level tag ${cls}">${p.level}</div>
                    </div>
                </div>`;
            });

            const overlay = isCoach ? `<div class="coaching-overlay">ğŸ¸ æ•™ç·´æŒ‡å°ä¸­ ğŸ¸</div>` : '';
            const courtClass = `court ${isOccupied ? 'occupied' : ''} ${isTarget ? 'target-mode' : ''} ${isSwapping ? 'swapping' : ''} ${isCoach ? 'coaching-mode' : ''}`;

            html += `
            <div class="${courtClass}" ${isTarget?`onclick="movePrepToCourtEnd(${i})"`:''}>
                ${overlay}
                <div class="court-header">
                    <div class="court-controls">
                        <div class="court-title">å ´åœ° ${i+1}</div>
                    </div>
                </div>
                <div class="court-actions" style="margin-bottom:8px;">
                    ${!isTarget ? `
                    <button class="btn-court-action btn-swap" onclick="event.stopPropagation(); initiateSwap(${i})">â‡„ äº¤æ›</button>
                    <button class="btn-court-action btn-auto-court" onclick="event.stopPropagation(); autoAssignSingle(${i})">ğŸ² è‡ªå‹•</button>
                    <button class="btn-court-action btn-speak" onclick="event.stopPropagation(); speakCourt(${i})">ğŸ“£ å«å</button>
                    <button class="btn-court-action btn-coach ${isCoach?'active':''}" onclick="event.stopPropagation(); toggleCoaching(${i})">${coachBtnText}</button>
                    <button class="btn-court-action btn-clear" onclick="event.stopPropagation(); clearCourt(${i})">ğŸ çµæŸ</button>
                    ` : '<div style="width:100%;text-align:center;color:red;font-weight:bold;padding:5px;">ğŸ‘‡ é»æ“Šæ­¤è™•ç§»å…¥</div>'}
                </div>
                <div class="team">${slots[0]}${slots[1]}</div>
                <div class="net"></div>
                <div class="team">${slots[2]}${slots[3]}</div>
            </div>`;
        });
        grid.innerHTML = html;
        renderPrep();
    }

    function renderPrep() {
        const container = document.getElementById('prepContainer');
        let html = '';
        prepCourts.forEach((row, rIdx) => {
            const isMoving = (movingPrepIndex === rIdx);
            const slots = row.map((p, i) => {
                if(!p) return `<div class="slot" onclick="clickPrepSlot(${rIdx},${i})"><span style="color:#ccc;">+</span></div>`;
                const cls = (p.level<=6)?'lvl-low':(p.level>=11?'lvl-high':'lvl-mid');
                const uStar = p.isUniversal ? 'ğŸŒŸ' : '';
                return `<div class="slot filled" onclick="clickPrepSlot(${rIdx},${i})">
                    <div class="remove-slot-btn" onclick="removePrepSlot(${rIdx},${i},event)">Ã—</div>
                    <div class="slot-content">
                        <div class="slot-name" style="font-size:16px;">
                            ${uStar}${p.name}
                            <span style="font-size:12px; color:#555;">(${p.count})</span>
                        </div>
                        <div class="slot-level tag ${cls}">${p.level}</div>
                    </div>
                </div>`;
            }).join('');

            html += `
            <div class="prep-row ${isMoving?'moving-mode':''}">
                <div class="prep-header">
                    <span class="prep-label">å‚™æˆ°å€ ${String.fromCharCode(65+rIdx)}</span>
                    <div class="prep-actions">
                        <button class="btn-court-action btn-auto-court" onclick="autoFillPrep(${rIdx})">ğŸ² è‡ªå‹•</button>
                        <button class="btn-court-action btn-move-in" onclick="movePrepToCourtStart(${rIdx})">ğŸš€ å…¥å ´</button>
                        <button class="btn-court-action btn-clear" onclick="clearPrep(${rIdx})">æ¸…é™¤</button>
                    </div>
                </div>
                <div class="team" style="margin-top:5px;">${slots}</div>
            </div>`;
        });
        container.innerHTML = html;
    }

    function renderPlayerList() {
        const waitList = document.getElementById('playerList');
        const restList = document.getElementById('restList');
        const absentList = document.getElementById('absentList');
        
        waitList.innerHTML = ''; restList.innerHTML = ''; absentList.innerHTML = '';
        
        const waiting = players.filter(p => !p.onCourt && !p.isResting && !p.isAbsent && !prepCourts.some(r=>r.includes(p)));
        document.getElementById('waitCount').innerText = waiting.length;

        // Visual Sort
        const displaySorted = [...waiting].sort((a,b) => (a.count - b.count) || (a.lastPlayedTime - b.lastPlayedTime));

        const createCard = (p, type) => {
            const cls = (p.level<=6)?'lvl-low':(p.level>=11?'lvl-high':'lvl-mid');
            const partner = p.partnerId ? 'â¤ï¸' : '';
            const bl = p.blacklist.length ? 'ğŸš«' : '';
            const sel = selectedPlayerId===p.id ? 'selected' : '';
            
            let actionBtn = '';
            let universalBtn = `<button class="btn-mini ${p.isUniversal ? 'btn-universal' : 'btn-universal-off'}" onclick="toggleUniversal('${p.id}', event)" title="è¨­å®šç‚ºç™½æ­ç‹">${p.isUniversal ? 'ğŸŒŸ' : 'ğŸƒ'}</button>`;
            let absentBtn = '';

            if (type === 'absent') {
                actionBtn = `<button class="btn-mini btn-arrive" onclick="toggleAbsent('${p.id}',event)" title="å ±åˆ°">âœ…</button>`;
                universalBtn = ''; 
            } else {
                const restIcon = (type === 'rest') ? 'â¬†ï¸' : 'ğŸ’¤';
                const restClass = (type === 'rest') ? 'btn-active' : 'btn-rest';
                actionBtn = `<button class="btn-mini ${restClass}" onclick="toggleRest('${p.id}',event)">${restIcon}</button>`;
                absentBtn = `<button class="btn-mini btn-absent" onclick="toggleAbsent('${p.id}',event)" title="è¨­ç‚ºæœªåˆ°/å¤–å‡º">ğŸšª</button>`;
            }
            
            const timeStr = p.arrivalTime ? `ğŸ•’${p.arrivalTime}` : '';
            const uClass = p.isUniversal ? 'universal-player' : '';
            const absentClass = (type === 'absent') ? 'absent' : '';
            const restClassCard = (type === 'rest') ? 'resting' : '';

            return `
            <div class="player-card ${sel} ${restClassCard} ${absentClass} ${uClass}" onclick="selectPlayer('${p.id}')">
                <div style="display:flex;align-items:center;">
                    <span class="tag ${cls}" ondblclick="event.stopPropagation(); editLevel('${p.id}')" title="é›™æ“Šä¿®æ”¹ç¨‹åº¦">${p.level}</span>
                    <span class="name-edit" ondblclick="event.stopPropagation(); renamePlayer('${p.id}')" title="é›™æ“Šä¿®æ”¹åå­—">${partner}${bl}${p.name}</span>
                </div>
                <div style="display:flex;align-items:center;">
                    <span class="time-badge">${timeStr}</span>
                    <span class="count-badge">${p.count}</span>
                    ${universalBtn}
                    ${actionBtn}
                    ${absentBtn}
                    <span class="delete-btn" onclick="removePlayer('${p.id}',event)">Ã—</span>
                </div>
            </div>`;
        };

        displaySorted.forEach(p => waitList.innerHTML += createCard(p, 'wait'));
        players.filter(p => p.isResting && !p.isAbsent).forEach(p => restList.innerHTML += createCard(p, 'rest'));
        players.filter(p => p.isAbsent).forEach(p => absentList.innerHTML += createCard(p, 'absent'));
    }

    function selectPlayer(id) { selectedPlayerId = (selectedPlayerId===id)?null:id; renderPlayerList(); renderPrep(); renderCourts(); }

    function renderHistory() {
        const ul = document.getElementById('historyListMain'); ul.innerHTML = '';
        matchHistory.forEach((m, idx) => {
            const names = m.detail.map(d=>`${d.name}(${d.level})`).join('+');
            const num = matchHistory.length - idx;
            const timeInfo = m.startTimeStr ? `${m.startTimeStr}~${m.endTimeStr} (${m.durationStr})` : m.time;

            ul.innerHTML += `
            <li class="history-item">
                <div class="history-header">
                    <span class="match-badge">#${num}</span>
                    <span class="history-time">${timeInfo}</span>
                    <span class="delete-hist-btn" onclick="deleteHistoryItem(${idx})">Ã—</span>
                </div>
                <div class="history-players">${names}</div>
            </li>`;
        });
    }

    function deleteHistoryItem(idx) {
        if(confirm("åˆªé™¤æ­¤ç­†ç´€éŒ„?")) { matchHistory.splice(idx, 1); saveData(); renderHistory(); }
    }

    function clearCourt(i) {
        if(courtCoaching[i]) return;
        const c = courts[i]; if(!c.some(x=>x)) return;
        if(!confirm("çµæŸä¸¦æ¸…ç©º?")) return;
        
        const pIds = c.filter(x=>x).map(x=>x.id);
        const pDet = c.filter(x=>x).map(x=>({name:x.name, level:x.level}));
        const endTime = Date.now();
        
        let startTime = endTime;
        c.forEach(p => {
            if(p && p.currentStartTime && p.currentStartTime < startTime) startTime = p.currentStartTime;
        });
        
        const formatTime = (ts) => new Date(ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        const durationMins = Math.round((endTime - startTime) / 60000);
        
        if(pIds.length>0) {
            matchHistory.unshift({
                id: Date.now(), 
                time: formatTime(endTime), 
                startTimeStr: formatTime(startTime),
                endTimeStr: formatTime(endTime),
                durationStr: durationMins + "åˆ†",
                playerIds: pIds, 
                detail: pDet
            });
            if(matchHistory.length>200) matchHistory.pop();
        }
        
        // V16: Only record counts here
        courts[i].forEach((p, idx) => { 
            if(p){ 
                recordGameStats(p); 
                resetPlayerState(p); 
                courts[i][idx]=null; 
            }
        });
        saveData(); renderAll();
    }

    // --- Persist ---
    function saveData() {
        const d = { 
            players, matchHistory, 
            courts: courts.map(c=>c.map(p=>p?p.id:null)),
            prepCourts: prepCourts.map(r=>r.map(p=>p?p.id:null)), 
            nCourts: document.getElementById('courtCount').value,
            courtCoaching,
            voice: document.getElementById('voiceSelect').value
        };
        localStorage.setItem('badAppV20', JSON.stringify(d)); // Version Bump to V20
    }
    function loadData() {
        const d = JSON.parse(localStorage.getItem('badAppV20'));
        if(d) {
            players = (d.players||[]).map(p => ({
                ...p, 
                isResting: p.isResting||false, 
                isAbsent: p.isAbsent || false, 
                isUniversal: p.isUniversal || false, 
                blacklist: p.blacklist||[], 
                partnerId: p.partnerId||null,
                arrivalTime: p.arrivalTime || '',
                totalPlayTime: p.totalPlayTime || 0,
                currentStartTime: p.currentStartTime || null,
                matchEndTimes: p.matchEndTimes || [] 
            }));
            matchHistory = d.matchHistory || [];
            document.getElementById('courtCount').value = d.nCourts || 4;
            courtCoaching = d.courtCoaching || [];
            if(d.voice) document.getElementById('voiceSelect').value = d.voice;
            
            courts = (d.courts || []).map(ids => ids.map(id => players.find(p=>p.id===id)||null));
            if(d.prepCourts) {
                prepCourts = d.prepCourts.map(ids => ids.map(id => players.find(p=>p.id===id)||null));
            }
        }
    }
    function saveSettings() { saveData(); }
    
    function clearAllData() {
        if(confirm("æ¸…é™¤æ‰€æœ‰è³‡æ–™?")) {
            localStorage.removeItem('badAppV20'); localStorage.removeItem('badBg');
            location.reload();
        }
    }
    function clearHistory() { if(confirm("æ¸…ç©ºç´€éŒ„?")) { matchHistory=[]; saveData(); renderHistory(); }}
    function resetAllCourts() { if(confirm("æ¸…ç©ºå ´åœ°?")) { courts.forEach(c=>c.forEach(p=>{if(p){resetPlayerState(p);}})); courts=courts.map(c=>[null,null,null,null]); saveData(); renderAll(); }}
    
    function showStats() {
        const b = document.getElementById('statsBody'); b.innerHTML='';
        const now = Date.now();
        [...players].sort((a,b)=>b.count-a.count).forEach(p=>{
            const t = p.arrivalTime || '-';
            let restTimeStr = '-';
            if (!p.onCourt && p.lastPlayedTime > 0) {
                const mins = Math.round((now - p.lastPlayedTime) / 60000);
                restTimeStr = mins + " åˆ†";
            } else if (p.onCourt) {
                restTimeStr = "æ¯”è³½ä¸­";
            }
            const historyStr = (p.matchEndTimes || []).join('; ');
            const uStr = p.isUniversal ? 'æ˜¯' : '';

            b.innerHTML+=`<tr>
                <td>${p.name}</td>
                <td>${p.level}</td>
                <td>${uStr}</td>
                <td>${p.count}</td>
                <td>${t}</td>
                <td>${restTimeStr}</td>
                <td style="font-size:12px; color:#666;">${historyStr}</td>
            </tr>`;
        });
        document.getElementById('statsModal').style.display='flex';
    }
    function closeModal(id) { document.getElementById(id).style.display='none'; }
    function renderAll() { renderPlayerList(); renderCourts(); renderPrep(); renderHistory(); }
    
    function handleBgUpload(e) {
        const f = e.target.files[0]; if(!f) return;
        const r = new FileReader();
        r.onload = (evt) => { try{localStorage.setItem('badBg', evt.target.result); loadBgImage();}catch(e){alert("åœ–ç‰‡å¤ªå¤§");} };
        r.readAsDataURL(f);
    }
    function loadBgImage() { const d = localStorage.getItem('badBg'); if(d) document.getElementById('bgLayer').style.backgroundImage=`url('${d}')`; }

    // ... (Partner/Blacklist Modals) ...
    function showPartnerModal() {
        const s1 = document.getElementById('partnerP1'), s2 = document.getElementById('partnerP2');
        s1.innerHTML = '<option value="">é¸äºº...</option>'; s2.innerHTML = '<option value="">é¸äºº...</option>';
        players.filter(p=>!p.partnerId).sort((a,b)=>a.name.localeCompare(b.name)).forEach(p=>{
            const o = `<option value="${p.id}">${p.name}</option>`; s1.innerHTML+=o; s2.innerHTML+=o;
        });
        const tb = document.getElementById('partnerListBody'); tb.innerHTML='';
        const done = new Set();
        players.forEach(p => {
            if(p.partnerId && !done.has(p.id)) {
                const p2 = players.find(x=>x.id===p.partnerId);
                if(p2) {
                    done.add(p.id); done.add(p2.id);
                    tb.innerHTML += `<tr><td>${p.name}</td><td>${p2.name}</td><td><button class="btn-mini" style="background:red;color:white" onclick="breakPartner('${p.id}')">è§£æ•£</button></td></tr>`;
                }
            }
        });
        document.getElementById('partnerModal').style.display='flex';
    }
    function addPartner() {
        const id1 = document.getElementById('partnerP1').value, id2 = document.getElementById('partnerP2').value;
        if(!id1 || !id2 || id1===id2) return alert("è«‹é¸å…©äºº");
        players.find(p=>p.id===id1).partnerId = id2; players.find(p=>p.id===id2).partnerId = id1;
        saveData(); showPartnerModal(); renderPlayerList();
    }
    function breakPartner(id) {
        const p1 = players.find(p=>p.id===id);
        if(p1 && p1.partnerId) {
            const p2 = players.find(x=>x.id===p1.partnerId);
            p1.partnerId = null; if(p2) p2.partnerId = null;
            saveData(); showPartnerModal(); renderPlayerList();
        }
    }
    function showBlacklistModal() {
        const s1 = document.getElementById('blP1'), s2 = document.getElementById('blP2');
        s1.innerHTML = '<option value="">é¸äºº...</option>'; s2.innerHTML = '<option value="">é¸äºº...</option>';
        players.sort((a,b)=>a.name.localeCompare(b.name)).forEach(p=>{
            const o = `<option value="${p.id}">${p.name}</option>`; s1.innerHTML+=o; s2.innerHTML+=o;
        });
        const tb = document.getElementById('blacklistBody'); tb.innerHTML='';
        const done = new Set();
        players.forEach(p => {
            p.blacklist.forEach(tid => {
                const key = [p.id, tid].sort().join('-');
                if(!done.has(key)) {
                    const t = players.find(x=>x.id===tid);
                    if(t) {
                        done.add(key);
                        tb.innerHTML += `<tr><td>${p.name}</td><td>${t.name}</td><td><button class="btn-mini" onclick="removeBlacklist('${p.id}','${tid}')">å–æ¶ˆ</button></td></tr>`;
                    }
                }
            });
        });
        document.getElementById('blacklistModal').style.display='flex';
    }
    function addBlacklist() {
        const id1 = document.getElementById('blP1').value, id2 = document.getElementById('blP2').value;
        if(!id1 || !id2 || id1===id2) return alert("è«‹é¸å…©äºº");
        const p1 = players.find(p=>p.id===id1), p2 = players.find(p=>p.id===id2);
        if(!p1.blacklist.includes(id2)) p1.blacklist.push(id2);
        if(!p2.blacklist.includes(id1)) p2.blacklist.push(id1);
        saveData(); showBlacklistModal();
    }
    function removeBlacklist(id1, id2) {
        const p1 = players.find(p=>p.id===id1), p2 = players.find(p=>p.id===id2);
        if(p1) p1.blacklist = p1.blacklist.filter(x=>x!==id2);
        if(p2) p2.blacklist = p2.blacklist.filter(x=>x!==id1);
        saveData(); showBlacklistModal();
    }
    function exportCSV() {
        const link = document.createElement("a");
        const now = Date.now();
        const csvContent = "å§“å,ç¨‹åº¦,ç™½æ­ç‹,ä¸Šå ´æ¬¡æ•¸,åˆ°å ´æ™‚é–“,ç›®å‰ä¼‘æ¯(åˆ†),ä¸‹å ´æ™‚é–“ç´€éŒ„\n" + 
            players.map(p => {
                let rest = '-';
                if (!p.onCourt && p.lastPlayedTime > 0) rest = Math.round((now - p.lastPlayedTime) / 60000);
                const history = (p.matchEndTimes || []).join('; ');
                const uStr = p.isUniversal ? 'æ˜¯' : '';
                return `${p.name},${p.level},${uStr},${p.count},${p.arrivalTime||''},${rest},${history}`;
            }).join('\n');
        
        link.href = 'data:text/csv;charset=utf-8,\uFEFF'+encodeURI(csvContent);
        link.download = `çµ±è¨ˆ.csv`; link.click();
    }
</script>
</body>
</html>